---
layout:     post                    # 使用的布局（不需要改）
title:   深入理解java虚拟机(二)          # 标题 
subtitle:   deep in JVM #副标题
date:       2019-04-30            # 时间
author:     Kinsomy                      # 作者
header-img:    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - JVM
    - Java
---
## 1.内存回收
### 1.1 判断对象是否存活
垃圾收集器会对不再被使用的对象进行GC操作，那么就要判断一个对象是否存活，有以下几种算法：
#### 1.1.1 引用计数算法
概述：对堆内存中的每个对象添加一个引用计数器，有其他地方引用它计数器加一，引用断开就减一。

优点：算法时间简单，判端高效。

缺点：难以解决对象之间循环引用的问题。

```java
class O {
    public Object o;
}

O oa = new O();
O ob = new O();
oa.o = ob;
ob.o = oa;
```

#### 1.1.2 可达性分析算法
概述：GC Roots作为根引用点，当一个对象从GC Roots往下追溯无法被到达时，那这个对象就不可用，可以被GC。

![](https://github.com/KinsomyJS/KinsomyJS.github.io/blob/master/img/jvm/2.png?raw=true)

图上左边的对象都是GC Roots可达的，不可回收，右边的对象是可以回收的。

可以作为GC Roots的对象包括：
* 虚拟机栈（栈帧中的本地变量表）中引用的对象。

* 方法区中类静态属性引用的对象。

* 方法区中常量引用的对象。

* 本地方法栈中JNI（即一般说的Native方法）引用的对象。


### 1.2 引用类型

强引用是正常new出来的引用，垃圾收集器不会回收强引用对象。

软引用是有用但不是必需保留的对象，弱于强引用，当系统内存宽裕时不会回收这些对象，但是如果内存紧张，将要有溢出风险时，会考虑回收软引用对象。

弱引用是比软引用更弱一些的引用对象，弱引用对象只能存活到下一次GC到来之前，不管下一次的GC时内存是否充裕，弱引用对象都会回收。

虚引用是最弱的引用，虚引用的作用仅仅是在运行时该对象被回收后获得通知。


### 1.3 垃圾收集算法
#### 1.3.1 标记-清除算法
概述：通过上面讲到的算法来判断每个对象是否要被回收，如果要被回收，则加上标记，标记完成后对所有被标记的对象统一回收。

缺点：标记和清除的过程效率不高；清除之后会有大量不连续的内存碎片，这些被清除后产生的可用内存不能组成连续内存，无法给内存需求较大的对象分配空间。

![](https://github.com/KinsomyJS/KinsomyJS.github.io/blob/master/img/jvm/3.png?raw=true)

#### 1.3.2 复制算法
概述：将内存分成两半，每次只使用其中一半的区域，当一半内存耗尽时，将还存活的对象复制到另一半区域，同时回收当前部分的内存。

优点：解决了标记-清除算法带来的内存碎片问题。

缺点：只能使用一半内存，另一半处于空闲，太过浪费。

![](https://github.com/KinsomyJS/KinsomyJS.github.io/blob/master/img/jvm/4.png?raw=true)
HotSpot虚拟机的复制算法使用的是一块Eden空间和两块Survivor控件，大小是8:1:1,用来回收新生代对象，（新生代对象被回收的概率大）。每次使用Eden控件和一块survivor空间，回收后将存活的对象复制到另一块survivor空间，然后清除Eden和上一个survivor。这样有效地降低内存浪费。但是对于老年代的对象回收则不那么适用。

#### 1.3.3 标记-整理算法
标记的过程和标记-清除算法类似，但是在清除无用对象之后，还需要将存活的对象向内存空间的一端移动，并更新引用其对象的指针。

优点：不会产生内存碎片。

缺点：增加了移动过程，增加算法成本。
![](https://github.com/KinsomyJS/KinsomyJS.github.io/blob/master/img/jvm/5.png?raw=true)


#### 1.3.4 分代收集算法
商业虚拟机普遍采用的算法，将java堆分为“新生代”和“老年代”，对新生代采用复制算法，对老年代采用标记-整理算法。

## 2 垃圾收集器


### 参考资料
* 深入理解Java虚拟机：JVM高级特性与最佳实践