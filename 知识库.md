### 1、临柜业务全面无纸化
营业部业务办理、上门业务办理携带pad即可

无纸化协议，视频双录单录、连线视频见证

### 2、RN热更新

对使用三方平台比较敏感，自研rn热更新方案

apk版本号和bundle版本号融合管理

“安全模式”，热更新出现异常得回退机制

### 3、负责纯flutter项目开发
需求设计和对接

社区、资讯、行情

getx状态管理

### 4、react native内存优化

### 5、Kotlin 的内部类是否默认持有外部对象的引用
kotlin内部类分为两种情况分析

默认情况下，内部类是静态内部类，是无法持有和使用外部类对象和引用的，这个时候不会造成内存泄漏

如果使用inner关键字声明内部类，就变成了Java的内部类，可以持有外部类引用，同时有可能造成内存泄漏


### 6、Android事件分发机制
Android 事件分发机制用到了责任链模式。

事件从当前Activity开始分发，activity默认不消费事件，activity传递给window，Window传给根View DecorView。

事件到达ViewGroup的dispatchTouchEvent，如果返回true，则事件传递结束被消费

dispatchTouchEvent返回false则继续传递

ViewGroup 特有onInterceptTouchEvent的拦截事件，他返回true会走ViewGroup的onTouchEvent

如果走到最上层的view仍没有被拦截，则会反向传递，onTouchEvent接受传递事件，直到返回true被消费为止。


### 7、OkKttp流程
![](https://blog.yorek.xyz/assets/images/android/okhttp_overview.jpg)

### 8、线程池
* FixedThreadPool 线程数量固定、队列大小没有限制的线程池，只有核心线程并且这些核心线程不会被回收
* SingleThreadExecutor 单一线程、队列大小没有限制的线程池
* CachedThreadPool 线程数量不定的线程池，只有非核心线程，并且其最大线程数为Integer.MAX_VALUE
* ScheduledThreadPool 核心线程数量固定、非核心线程数量没有限制、非核心线程闲置时间10s的线程池

### 9、ASM 字节码插桩进行线程治理 ASM统计方法耗时 Lint检查禁止随意new Thread

### 10、热更新原理
美团Robust：DexClassLoader把补丁包插到加载list最前面，然后通过反射找到需要修复的类，把原来基准包类里设置的静态变量替换掉

阿里Sophix：Java的方法在ART虚拟机中有对应的ArtMethod结构体，替换该结构体 可以实时更新 只要取到ArtMethod的size就可以通过JNI提供的 void *memcpy(void *, const void *, size_t) ，把destMethod的内容复制到 srtMethod即可。

### 11、插件化

### 12、类加载器
一般都是用DexClassLoader作为动态加载的加载器。
DexPathList#findClass在查找指定类时，会按顺序遍历dexElements数组，只要找到就会立刻返回。而且由于双亲委托模型的存在，不会重复加载同一个class。
因此，只要我们先加载修复好bug的class文件，那么就不会加载有bug的class了。

### 13、ANR
ANR日志在data/anr

前台ANR弹窗，后台ANR直接杀死进程

服务启动ANR：

前台服务20s，后台服务200s，startService时handler发一个timeout延迟消息，然后去创建service，service创建完后通知AMS移除消息，如果在timeout时间内没有移除，就触发ANR
- Service 的生命周期的回调方法执行慢
- 主线程的消息队列存在其他耗时消息让 Service 回调方法迟迟得不到执行
- sp 操作执行慢
- system_server 进程的 binder 线程繁忙而导致没有及时收到拆炸弹的指令


Input服务ANR： 5s超时，下一个输入事件到来时检测前一个事件是否超时，超时则ANR

ANR的发生场景只有4种：Service Timeout、BroadcastQueue Timeout、ContentProvider Timeout、InputDispatching Timeout。

[https://mp.weixin.qq.com/s/qQAPg0PwefYhScdN5bBPnA](https://mp.weixin.qq.com/s/qQAPg0PwefYhScdN5bBPnA)

### 14、PECS
extends只读，不知道具体类型，都是返回超类

super 可以写数据，但是取数据都返回object类 

### 15、IPC机制

| 名称            | 优点                                                                           | 缺点                                                                                             | 使用场景                                         |
| --------------- | ------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------ | ------------------------------------------------ |
| Bundle          | 简单易用                                                                       | 只能传输Bundle支持的数据                                                                         | 四大组件之间的进程间通信                         |
| 文件共享        | 简单易用                                                                       | 不适合高并发场景，且无法做到进程间的即时通信                                                     | 无并发访问情况，交换简单的数据，实时性不高的场景 |
| AIDL            | 功能强大，支持一对多并发通信，支持实时通信                                     | 使用稍复杂，需要处理好线程同步                                                                   | 一对多通信且有RPC需求                            |
| Messenger       | 功能一般，支持一对多串行通信，支持实时通信                                     | 不能很高的处理高并发情形，不支持RPC，数据通过Messenger进行传输，因此只能传输Bundle支持的数据类型 | 低并发的一对多即时通信，无RPC需求                |
| ContentProvider | 在数据源访问方面功能强大，支持一对多并发数据访问，可以通过Call方法扩展其他操作 | 可以理解为受约束的AIDL，主要提供对数据源CRUD操作                                                 | 一对多的进程间的数据共享                         |
 Socket | 功能强大，可以通过网络传输字节流，支持一对多并发实时通信	 | 实现细节略嫌麻烦，不支持直接的RPC	|网络数据交换

 ### 16、let、with、run、apply和also

 let with run 最后一行是返回值，apply also返回this

 let also it指代当前对象，with run apply 用this指代当前对象

 ### 17、equals和hashCode
 equals 比较引用是否指向同一个内存

 == 基础类型比较值是否相等 非基础类型比较内存地址是否相同


 ### 18、LinkedHashMap和hashMap的区别
 LinkedHashMap基于链表 有序

 hashMap 基于hash表 乱序

 ### 19、Flutter三棵树

Widget树、Element树和RenderObject树。
* Widget树：控件的配置信息，不涉及渲染，更新代价极低。
* RenderObject树：真正的UI渲染树，负责渲染UI，更新代价极大。
* Element树：Widget树和RenderObject树之间的粘合剂,负责将Widget树的变更以最低的代价映射到RenderObject树上。

### 20、ArrayMap
两个数组，一个数组保存hashcode，另一个数组保存对应的keyvalue对象

扩容机制 0-4的时候容量是4 4-8容量是8 大于等于8时，进行1.5倍扩容

remove时会适当减小数组容量

二分查找，数据量较大（超过1000条）时效率低下

### 21、SparseArray 

初始容量10，可以指定初始容量

二分查找

删除操作 标记未DELETE，并不会真的移除

### 22、AQS
CHL双端队列，队首出列，队尾插入，CAS更新数据，state表示是否抢占锁

抢占式和共享式

**抢占式** ：acquire release 

ReentrantLock、ReentrantReadWriteLock.WriteLock

**共享式**： acquireShared  releaseShared  

ReentrantReadWriteLock.ReadLock、CountDownLatch、CyclicBarrier、Semaphore