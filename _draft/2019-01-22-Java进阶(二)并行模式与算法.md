---
layout:     post                    # 使用的布局（不需要改）
title:   Java进阶(二)并行模式预算法          # 标题 
subtitle:   java concurrent programming #副标题
date:       2019-01-22            # 时间
author:     Kinsomy                      # 作者
header-img:    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - Java
---

这篇文章是对《Java高并发编程》第五章的记录，同时结合自己查找的资料做集中总结。

并发编程里面会有一些常用的设计模式。

## 单例模式
自不用说，单例是最常见的一种设计模式，是为了避免对象重复创建。
有两大好处：

* 对于频繁使用的对象，可以省略new操作花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；

* 由于new操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻GC压力，缩短GC停顿时间。

几种单例写法在这里不做罗列，google一大堆。因为是并发相关，
直接看懒汉式单例
```java
public class Singleton {  
    private static Singleton instance;  
    private Singleton (){}  
    public static synchronized Singleton getInstance() {  
    if (instance == null) {  
        instance = new Singleton();  
    }  
    return instance;  
    }  
}
```
这种写法为了防止instance在多线程中被多次创建，对getInstance用了synchronized加锁，但是在并发激烈的场合下，会造成锁竞争激烈，影响性能。所以最优写法就是静态内部类：

```java
public class Singleton {  
    private static class SingletonHolder {  
    private static final Singleton INSTANCE = new Singleton();  
    }  
    private Singleton (){}  
    public static final Singleton getInstance() {  
    return SingletonHolder.INSTANCE;  
    }  
}
```
巧妙利用静态内部类加载时机，在需要初始化的时候主动调用才会构造instance对象实现懒加载，同时没有用锁，性能优越。

## 不变模式
不变模式在多线程环境下始终保持`内部状态的一致性和正确性`。

不变模式的使用场景满足两个条件：
* 当对象创建后，其内部状态和数据不再发生任何变化。
* 对象需要被共享，被多线程频繁访问。

不变对象和只读对象是有区别的，不变对象是从创建之后就不会再改变，内部的属性都不会变化，只读对象是外部不可修改，内部可以自变化。

不变对象的注意点:
* 去除setter方法以及所有修改自身属性的方法。
* 将所有属性设置为私有，并用final标记。
* 确保没有子类可以重载修改它的行为。
* 有一个可以创建完整对象的构造函数。

典型案例：java.lang.String,Boolean,Byte等lang包下数据类型。





